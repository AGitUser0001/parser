import { Graph, isGeneric, type GraphToken, Choice, Sequence, type GraphCollection, type StandaloneOperator, type StateKey, type StateName, type IterationOperator, type Generic, OP_MAP } from './graph.js';
import type { SccId } from './scc.js';
import type { MapView } from './shared.js';
import { logic, type Resources, type Fn } from './emit.js';

export type ResultValue =
  | Result
  | Result[]
  | MatcherValue
  | null;

export type BaseResult = {
  ok: boolean;
  pos: number;
  value: ResultValue;
  ws?: MatcherValue | null;
};
export type Result =
  | BaseResult & { type: 'none'; ok: false; value: null; }
  | BaseResult & { type: 'lookahead'; positive: boolean; value: Result; }
  | BaseResult & { type: 'state'; state: StateName; value: Result; }
  | BaseResult & { type: 'choice'; value: Result; alt: number | null; }
  | BaseResult & { type: 'sequence'; value: Result[]; }
  | BaseResult & { type: 'terminal'; value: MatcherValue; ok: true; }
  | BaseResult & { type: 'terminal'; value: null; ok: false; }
  | BaseResult & { type: 'iteration'; kind: IterationOperator; value: Result[]; }
  | BaseResult & { type: 'rewind'; value: Result; }
  | BaseResult & { type: 'root'; trailing_ws: MatcherValue | null; value: Result & { type: 'state'; }; };

export type MatcherValue = string;

type MemoEntry = { result: Result; };
interface ParserCtx<K extends StateName> {
  readonly graph: Graph<K>;

  readonly sccOf: MapView<StateKey<K>, SccId>;
  readonly sccMembers: MapView<SccId, StateKey<K>[]>;

  readonly lexicalStates: Set<StateKey<K>>;
  bind(state: StateKey<K>, cb: (val: RV<K>) => void): void;
  logic<T extends (...args: any[]) => any = FnT<K>>(closure: T, resources: Resources<FnT<K, unknown>>): Fn<T, FnT<K, unknown>>
};

interface RuntimeCtx<K extends StateName> {
  readonly input: string;

  getMemo(state: StateKey<K>, pos: number): MemoEntry | undefined;
  setMemo(state: StateKey<K>, pos: number, entry: MemoEntry): void;

  readonly ws: RegExp;
};

function improves(next: Result, prev: Result): boolean {
  return next.ok && (!prev.ok || next.pos > prev.pos);
}

function improves_error(next: Result, prev: Result): boolean {
  return !prev.ok && !next.ok && (next.pos >= prev.pos);
}

export type FnT<K extends StateName, R = Result> = (rc: RuntimeCtx<K>, pos: number) => R;
export type RV<K extends StateName> = Fn<FnT<K>, FnT<K>>;
export type StateRV<K extends StateName> = Fn<FnT<K, Result & { type: 'state' }>, FnT<K>>;
function buildState<K extends StateName>(
  ctx: ParserCtx<K>,
  state: StateKey<K>
): StateRV<K> {
  const sid = ctx.sccOf.get(state);
  if (sid === undefined) {
    const x = evalStateBody(ctx, state, ctx.lexicalStates.has(state));
    return ctx.logic((rc, pos) => {
      const existing = rc.getMemo(state, pos);
      if (existing) {
        const result = existing.result;
        return { type: 'state', ok: result.ok, pos: result.pos, value: result, state };
      }

      const result = x(rc, pos);
      rc.setMemo(state, pos, { result });
      return { type: 'state', ok: result.ok, pos: result.pos, value: result, state };
    }, { x, state });
  }

  const s = solveSCC(ctx, sid);
  return ctx.logic((rc, pos) => {
    const existing = rc.getMemo(state, pos);
    if (existing) {
      const result = existing.result;
      return { type: 'state', ok: result.ok, pos: result.pos, value: result, state };
    }

    s(rc, pos);

    const entry = rc.getMemo(state, pos);
    if (!entry)
      throw new Error(`Internal error: No result generated by solveSCC`, { cause: { state, entry, pos } });

    const result = entry.result;
    return { type: 'state', ok: result.ok, pos: result.pos, value: result, state };
  }, { s, state });
}

function solveSCC<K extends StateName>(
  ctx: ParserCtx<K>,
  sccId: SccId
): Fn<FnT<K, void>, FnT<K>> {
  const group = ctx.sccMembers.get(sccId);
  if (!group || group.length === 0)
    throw new Error(`Internal error: invalid scc group for ${sccId}`, { cause: { ctx, sccId, group } });

  let ev: RV<K>[] = [];
  for (let i = 0; i < group.length; i++) {
    const st = group[i];
    const x = evalStateBody(ctx, st, ctx.lexicalStates.has(st));
    ev.push(x);
  }

  if (ev.length === 1) {
    const x = ev[0];
    const st = group[0];
    return ctx.logic((rc, pos) => {
      let entry = rc.getMemo(st, pos);
      if (!entry) {
        entry = { result: { type: 'none', ok: false, pos, value: null } };
        rc.setMemo(st, pos, entry);
      }
      while (true) {
        const candidate = x(rc, pos);
        if (improves(candidate, entry.result)) {
          entry.result = candidate;
        } else if (improves_error(candidate, entry.result)) {
          entry.result = candidate;
          return;
        } else return;
      }
    }, { x, st });
  }

  return ctx.logic((rc, pos) => {
    let entries: MemoEntry[] = Array(group.length);
    for (let i = 0; i < group.length; i++) {
      const st = group[i];
      let memo = rc.getMemo(st, pos);
      if (!memo) {
        memo = { result: { type: 'none', ok: false, pos, value: null } };
        rc.setMemo(st, pos, memo);
      }
      entries[i] = memo;
    }
    let changed = true;
    while (changed) {
      changed = false;

      for (let i = 0; i < group.length; i++) {
        const entry = entries[i];
        const candidate = ev[i](rc, pos);

        if (improves(candidate, entry.result)) {
          entry.result = candidate;
          changed = true;
        } else if (improves_error(candidate, entry.result)) {
          entry.result = candidate;
        }
      }
    }
  }, { ev, group });
}

function evalStateBody<K extends StateName>(
  ctx: ParserCtx<K>,
  state: StateKey<K>,
  lexical: boolean
): RV<K> {
  const seq = ctx.graph.get(state);
  if (!seq)
    throw new Error(`Invalid state: ${state}`, { cause: { ctx, state } });

  return buildSequence(ctx, seq, lexical);
}

function skipWs(rc: RuntimeCtx<StateName>, pos: number): [MatcherValue | null, number] {
  rc.ws.lastIndex = pos;
  const match = rc.ws.exec(rc.input);
  if (match) {
    let ws = match[0];
    pos += ws.length;
    return [ws, pos];
  }
  return [null, pos];
};

function buildTerm<K extends StateName>(
  ctx: ParserCtx<K>,
  term: RegExp | StateKey<K> | Choice<K> | Sequence<K>,
  lexical: boolean
): RV<K> {
  if (term instanceof RegExp) {
    const x = buildRegex(ctx, term);
    if (lexical)
      return ctx.logic((rc, pos) => {
        const result = x(rc, pos);
        return result;
      }, { x });
    return ctx.logic((rc, pos) => {
      let ws;
      [ws, pos] = skipWs(rc, pos);
      const result = x(rc, pos);
      if (ws) result.ws = result.ws ? ws + result.ws : ws;
      return result;
    }, { x });
  } else if (term instanceof Sequence) {
    return buildSequence(ctx, term, lexical);
  } else if (term instanceof Choice) {
    return buildChoice(ctx, term, lexical);
  } else {
    let x: RV<K> = noop;
    ctx.bind(term, v => { x = v; });

    if (lexical)
      return ctx.logic((rc, pos) => {
        const result = x(rc, pos);
        return result;
      }, { toState: ['x', term] });
    return ctx.logic((rc, pos) => {
      let ws;
      [ws, pos] = skipWs(rc, pos);
      const result = x(rc, pos);
      if (ws) result.ws = result.ws ? ws + result.ws : ws;
      return result;
    }, { toState: ['x', term] });
  }
}
const noop: RV<StateName> = logic<FnT<StateName>, never>((rc, pos) => {
  throw new Error('Internal Error: noop reached.', { cause: { rc, pos } });
}, { a: logic(() => { }, {}) });

function buildSequence<K extends StateName>(
  ctx: ParserCtx<K>,
  seq: Sequence<K>,
  lexical: boolean
): RV<K> {
  const [_opMask, body] = seq.operators;
  lexical = lexScope(ctx, seq, lexical);
  let r: RV<K>;
  if (body.length === 1) {
    const term = body[0];
    throwOnGeneric(term);
    const x = buildTerm(ctx, term, lexical);
    r = ctx.logic((rc, pos) => {
      const r = x(rc, pos);
      return { type: 'sequence', ok: r.ok, pos: r.pos, value: [r] };
    }, { x });
  } else {
    const ev: RV<K>[] = [];
    for (const term of body) {
      throwOnGeneric(term);
      const x = buildTerm(ctx, term, lexical);
      ev.push(x);
    }
    r = ctx.logic((rc, pos) => {
      let curPos = pos;
      let results: Result[] = [];
      for (const x of ev) {
        const r: Result = x(rc, curPos);
        results.push(r); curPos = r.pos;
        if (!r.ok)
          return { type: 'sequence', ok: false, pos: curPos, value: results };
      }
      return { type: 'sequence', ok: true, pos: curPos, value: results };
    }, { ev });
  }
  return withOperators(ctx, seq, r, lexical);
}

function buildChoice<K extends StateName>(
  ctx: ParserCtx<K>,
  choice: Choice<K>,
  lexical: boolean
): RV<K> {
  const [opMask, body] = choice.operators;
  lexical = lexScope(ctx, choice, lexical);
  let r: RV<K>;
  if (body.length === 1) {
    const term = body[0];
    throwOnGeneric(term);
    const x = buildTerm(ctx, term, lexical);
    r = ctx.logic((rc, pos) => {
      const r = x(rc, pos);
      return { type: 'choice', ok: r.ok, pos: r.pos, value: r, alt: 0 };
    }, { x });
  } else {
    const ev: RV<K>[] = [];
    for (const term of body) {
      throwOnGeneric(term);
      const x = buildTerm(ctx, term, lexical);
      ev.push(x);
    }
    const hasOrderedChoice = opMask & OP_MAP['/'];
    if (hasOrderedChoice)
      r = ctx.logic((rc, pos) => {
        let error: Result = { type: 'none', ok: false, pos, value: null };
        let errorId: number | null = null;
        for (let i = 0; i < ev.length; i++) {
          const alt = ev[i];
          const r = alt(rc, pos);
          if (r.ok)
            return { type: 'choice', ok: r.ok, pos: r.pos, value: r, alt: i };
          if (improves_error(r, error)) {
            error = r;
            errorId = i;
          }
        }
        return { type: 'choice', ok: error.ok, pos: error.pos, value: error, alt: errorId };
      }, { ev });
    else
      r = ctx.logic((rc, pos) => {
        let best: Result = { type: 'none', ok: false, pos, value: null };
        let bestId: number | null = null;
        for (let i = 0; i < ev.length; i++) {
          const alt = ev[i];
          const r = alt(rc, pos);
          if (improves(r, best)) {
            best = r;
            bestId = i;
          } else if (improves_error(r, best)) {
            best = r;
            bestId = i;
          }
        }
        return { type: 'choice', ok: best.ok, pos: best.pos, value: best, alt: bestId };
      }, { ev });
  }
  return withOperators(ctx, choice, r, lexical);
}

function buildRegex<K extends StateName>(ctx: ParserCtx<K>, re: RegExp): RV<K> {
  if (!re.sticky || re.global)
    throw new Error(`matchRegex: Expected sticky and non-global regex, got: ${re.flags}`, { cause: re });

  return ctx.logic((rc, pos): Result => {
    re.lastIndex = pos;
    const m = re.exec(rc.input);

    if (!m) return { type: 'terminal', ok: false, pos, value: null };
    const value = m[0];
    return { type: 'terminal', ok: true, pos: pos + value.length, value };
  }, { re });
}

export type Operators<K extends StateName> = readonly [
  opMask: number,
  body: readonly (Exclude<GraphToken<K>, StandaloneOperator> | Generic)[]
];

function throwOnGeneric<K extends StateName>(x: Exclude<GraphToken<K>, StandaloneOperator> | Generic):
  asserts x is Exclude<GraphToken<K>, StandaloneOperator> {
  if (isGeneric(x))
    throw new Error(
      'Generic states must be referenced using a CallToken, not as plain state references.',
      { cause: x }
    );
}

function lexScope<K extends StateName>(
  ctx: ParserCtx<K>,
  data: GraphCollection<K>,
  lexical: boolean
): boolean {
  const [opMask, _body] = data.operators;

  const hasLex = opMask & OP_MAP['#'];
  const hasSyn = opMask & OP_MAP['%'];

  if (hasLex) lexical = true;
  else if (hasSyn) lexical = false;

  return lexical;
}

function withOperators<K extends StateName>(
  ctx: ParserCtx<K>,
  data: GraphCollection<K>,
  r: RV<K>,
  lexical: boolean
): RV<K> {
  const [opMask, _body] = data.operators;

  const hasPosLA = opMask & OP_MAP['&'];
  const hasNegLA = opMask & OP_MAP['!'];
  const hasStar = opMask & OP_MAP['*'];
  const hasPlus = opMask & OP_MAP['+'];
  const hasOpt = opMask & OP_MAP['?'];
  const hasAt = opMask & OP_MAP['@'];
  const hasRewind = opMask & OP_MAP['$'];

  if (hasAt) {
    const x = r;
    r = lexical ? ctx.logic((rc, pos) => {
      const r = x(rc, pos);
      return {
        type: 'iteration',
        ok: r.ok,
        pos: hasRewind ? (r.ok ? r.pos : pos) : r.pos,
        value: [r],
        kind: '@'
      };
    }, { x, hasRewind }) : ctx.logic((rc, pos) => {
      let [ws, runPos] = skipWs(rc, pos);
      const r = x(rc, runPos);
      return {
        type: 'iteration',
        ok: r.ok,
        pos: hasRewind ? (r.ok ? r.pos : pos) : r.pos,
        value: [r],
        kind: '@',
        ws
      };
    }, { x, hasRewind });
  } else if (hasOpt) {
    const x = r;
    r = lexical ? ctx.logic((rc, pos) => {
      const r = x(rc, pos);
      if (!r.ok && (hasRewind || r.pos === pos))
        return {
          type: 'iteration',
          ok: true,
          pos, value: [],
          kind: '?'
        };
      else
        return {
          type: 'iteration',
          ok: r.ok,
          pos: r.pos,
          value: [r],
          kind: '?'
        };
    }, { x, hasRewind }) : ctx.logic((rc, pos) => {
      let [ws, runPos] = skipWs(rc, pos);
      const r = x(rc, runPos);
      if (!r.ok && (hasRewind || r.pos === runPos))
        return {
          type: 'iteration',
          ok: true,
          pos, value: [],
          kind: '?'
        };
      else
        return {
          type: 'iteration',
          ok: r.ok,
          pos: r.pos,
          value: [r],
          kind: '?',
          ws
        };
    }, { x, hasRewind });
  } else if (hasStar) {
    const x = r;
    r = lexical ? ctx.logic((rc, pos) => {
      const results: Result[] = [];
      let curPos = pos;

      while (true) {
        const r = x(rc, curPos);
        if (r.pos === curPos) break;
        if (hasRewind && !r.ok) break;

        results.push(r);
        curPos = r.pos;
        if (!r.ok) break;
      }

      return {
        type: 'iteration',
        ok: results.length ? results[results.length - 1].ok : true,
        pos: curPos,
        value: results,
        kind: '*'
      };
    }, { x, hasRewind }) : ctx.logic((rc, pos) => {
      const results: Result[] = [];
      let curPos = pos;

      while (true) {
        let [ws, runPos] = skipWs(rc, curPos);
        const r = x(rc, runPos);
        if (ws) r.ws = r.ws ? ws + r.ws : ws;

        if (r.pos === runPos) break;
        if (hasRewind && !r.ok) break;
        results.push(r);
        curPos = r.pos;
        if (!r.ok) break;
      }

      return {
        type: 'iteration',
        ok: results.length ? results[results.length - 1].ok : true,
        pos: curPos,
        value: results,
        kind: '*'
      };
    }, { x, hasRewind });
  } else if (hasPlus) {
    const x = r;
    r = lexical ? ctx.logic((rc, pos) => {
      const results: Result[] = [];
      let curPos = pos;

      while (true) {
        const r = x(rc, curPos);
        if (results.length) {
          if (r.pos === curPos) break;
          if (hasRewind && !r.ok) break;
        }
        results.push(r);
        curPos = r.pos;
        if (!r.ok) break;
      }

      return {
        type: 'iteration',
        ok: results.length ? results[results.length - 1].ok : true,
        pos: curPos,
        value: results,
        kind: '+'
      };
    }, { x, hasRewind }) : ctx.logic((rc, pos) => {
      const results: Result[] = [];
      let curPos = pos;

      while (true) {
        let [ws, runPos] = skipWs(rc, curPos);
        const r = x(rc, runPos);
        if (ws) r.ws = r.ws ? ws + r.ws : ws;

        if (results.length) {
          if (r.pos === runPos) break;
          if (hasRewind && !r.ok) break;
        }
        results.push(r);
        curPos = r.pos;
        if (!r.ok) break;
      }

      return {
        type: 'iteration',
        ok: results.length ? results[results.length - 1].ok : true,
        pos: curPos,
        value: results,
        kind: '+'
      };
    }, { x, hasRewind });
  }

  // --- rewind ---
  if (hasRewind && !hasAt && !hasOpt && !hasStar && !hasPlus) {
    const x = r;
    r = ctx.logic((rc, pos) => {
      const result = x(rc, pos);
      return {
        type: 'rewind',
        ok: result.ok,
        pos: result.ok ? result.pos : pos,
        value: result
      }
    }, { x });
  }

  // --- lookahead ---
  if (hasPosLA) {
    const x = r;
    r = ctx.logic((rc, pos) => {
      const result = x(rc, pos);
      return {
        type: 'lookahead',
        ok: result.ok,
        pos,
        value: result,
        positive: true
      }
    }, { x });
  } else if (hasNegLA) {
    const x = r;
    r = ctx.logic((rc, pos) => {
      const result = x(rc, pos);
      return {
        type: 'lookahead',
        ok: !result.ok,
        pos,
        value: result,
        positive: false
      }
    }, { x });
  }

  return r;
}

const WS_REGEX = /\s+/y;
const LEXICAL_REGEX = /^[a-z_]/;
export type ParserFn<K extends StateName> = (input: string, start: StateKey<K>, ws?: RegExp) => Result & { type: 'root'; };
type ParserResources<K extends StateName> = {
  states: Map<StateKey<K>, StateRV<K>>,
  allStates: Set<StateKey<K>>,
  lexicalStates: Set<StateKey<K>>,
  WS_REGEX: RegExp
};
export type Parser<K extends StateName> = Fn<ParserFn<K>, FnT<K>> & { resources: ParserResources<K> };

export function build<K extends StateName>(
  graph: Graph<K>,
  metadata: true
): Parser<K>;
export function build<K extends StateName>(
  graph: Graph<K>,
  metadata?: false
): ParserFn<K>;
export function build<K extends StateName>(
  graph: Graph<K>,
  metadata: boolean
): ParserFn<K> | Parser<K>;
export function build<K extends StateName>(
  graph: Graph<K>,
  metadata = false
): ParserFn<K> | Parser<K> {
  const lexicalStates = new Set<StateKey<K>>();
  const allStates = new Set(graph.keys());
  const toBind = new Map<StateKey<K>, ((val: RV<K>) => void)[]>();
  for (const stateLabel of allStates) {
    if (LEXICAL_REGEX.test(stateLabel))
      lexicalStates.add(stateLabel);
    toBind.set(stateLabel, []);
  }

  const ctx: ParserCtx<K> = {
    graph,
    sccOf: graph.sccOf,
    sccMembers: graph.sccMembers,
    lexicalStates,
    bind(state, cb) {
      toBind.get(state)!.push(cb);
    },
    logic(closure, resources) {
      if (metadata)
        return logic(closure, resources);
      return closure as unknown as Fn<typeof closure, FnT<K, unknown>>;
    }
  };

  const states = new Map<StateKey<K>, StateRV<K>>();
  for (const [stateLabel, state] of graph.entries()) {
    if (state.generic) continue;
    states.set(stateLabel, buildState(ctx, stateLabel));
  }

  for (const [stateLabel, cbs] of toBind.entries()) {
    for (const cb of cbs)
      cb(states.get(stateLabel)!);
  }

  const parse: ParserFn<K> = (input, start, ws) => {
    ws ??= WS_REGEX;
    if (!ws.sticky || ws.global) {
      throw new Error("Whitespace regex must be sticky and non-global");
    }

    const x = states.get(start);
    if (!x && allStates.has(start))
      throw new Error(`Cannot start at generic state: ${start}`, { cause: { input, start } });
    if (!x)
      throw new Error(`Cannot start at unknown state: ${start}`, { cause: { input, start } });

    const memos = new Map<StateKey<K>, Map<number, MemoEntry>>();
    for (const stateLabel of allStates) {
      memos.set(stateLabel, new Map);
    }

    const rc: RuntimeCtx<K> = {
      input,

      getMemo(state, pos) {
        return memos.get(state)!.get(pos);
      },
      setMemo(state, pos, entry) {
        memos.get(state)!.set(pos, entry);
      },

      ws
    };

    const result = x(rc, 0);
    const lexical = lexicalStates.has(start);
    let trailing_ws = null, endPos = result.pos;
    if (!lexical) {
      [trailing_ws, endPos] = skipWs(rc, result.pos);
    }

    if (result.ok && endPos === input.length) {
      return {
        type: 'root',
        ok: true, pos: endPos, value: result,
        trailing_ws
      };
    }

    return {
      type: 'root',
      ok: false, pos: endPos, value: result,
      trailing_ws
    };
  };
  if (metadata)
    return ctx.logic(parse, { states, allStates, lexicalStates, WS_REGEX } satisfies ParserResources<K>);
  return parse;
}
