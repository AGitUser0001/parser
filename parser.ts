import { Graph, isGeneric, type GraphToken, Choice, Sequence, type GraphCollection, type StandaloneOperator, type StateKey, type StateName, type IterationOperator, type Generic, OP_MAP } from './graph.js';
import type { SccId } from './scc.js';
import type { MapView } from './shared.js';

export type ResultValue =
  | Result
  | Result[]
  | MatcherValue
  | null;

export type BaseResult = {
  ok: boolean;
  pos: number;
  value: ResultValue;
  ws?: MatcherValue | null;
};
export type Result =
  | BaseResult & { type: 'none'; ok: false; value: null; }
  | BaseResult & { type: 'lookahead'; positive: boolean; value: Result; }
  | BaseResult & { type: 'state'; state: StateName; value: Result; }
  | BaseResult & { type: 'choice'; value: Result; alt: number | null; }
  | BaseResult & { type: 'sequence'; value: Result[]; }
  | BaseResult & { type: 'terminal'; value: MatcherValue; ok: true; }
  | BaseResult & { type: 'terminal'; value: null; ok: false; }
  | BaseResult & { type: 'iteration'; kind: IterationOperator; value: Result[]; }
  | BaseResult & { type: 'attrs'; attrs: string[]; value: Result; }
  | BaseResult & { type: 'rewind'; value: Result; }
  | BaseResult & { type: 'root'; trailing_ws: MatcherValue | null; value: Result & { type: 'state'; }; };

export type MatcherValue = string;

type MemoEntry = { result: Result; };
type ParserCtx<K extends StateName> = Readonly<{
  graph: Graph<K>;

  sccOf: MapView<StateKey<K>, SccId>;
  sccMembers: MapView<SccId, StateKey<K>[]>;
  lexicalStates: Set<StateKey<K>>;
}>;


type RuntimeCtx<K extends StateName> = Readonly<{
  input: string;

  getMemo(state: StateKey<K>, pos: number): MemoEntry | null;
  setMemo(state: StateKey<K>, pos: number, entry: MemoEntry): void;
  call(state: StateKey<K>, pos: number): Result;

  ws: RegExp;
}>;

function improves(next: Result, prev: Result): boolean {
  return next.ok && (!prev.ok || next.pos > prev.pos);
}

function improves_error(next: Result, prev: Result): boolean {
  return !prev.ok && !next.ok && (next.pos >= prev.pos);
}

type RV<K extends StateName> = (rc: RuntimeCtx<K>, pos: number) => Result;
type StateRV<K extends StateName> = (rc: RuntimeCtx<K>, pos: number) => Result & { type: 'state'; };
function buildState<K extends StateName>(
  ctx: ParserCtx<K>,
  state: StateKey<K>
): StateRV<K> {
  const sid = ctx.sccOf.get(state);
  if (sid === undefined) {
    const x = evalStateBody(ctx, state, ctx.lexicalStates.has(state));
    return (rc: RuntimeCtx<K>, pos: number) => {
      const existing = rc.getMemo(state, pos);
      if (existing) {
        const result = existing.result;
        return { type: 'state', ok: result.ok, pos: result.pos, value: result, state };
      }

      const result = x(rc, pos);
      rc.setMemo(state, pos, { result });
      return { type: 'state', ok: result.ok, pos: result.pos, value: result, state };
    };
  }

  const s = solveSCC(ctx, sid);
  return (rc: RuntimeCtx<K>, pos: number) => {
    const existing = rc.getMemo(state, pos);
    if (existing) {
      const result = existing.result;
      return { type: 'state', ok: result.ok, pos: result.pos, value: result, state };
    }

    s(rc, pos);

    const entry = rc.getMemo(state, pos);
    if (!entry)
      throw new Error(`Internal error: No result generated by solveSCC`, { cause: { ctx, state, entry: entry, pos } });

    const result = entry.result;
    return { type: 'state', ok: result.ok, pos: result.pos, value: result, state };
  }
}

function solveSCC<K extends StateName>(
  ctx: ParserCtx<K>,
  sccId: SccId
): (rc: RuntimeCtx<K>, pos: number) => void {
  const group = ctx.sccMembers.get(sccId);
  if (!group || group.length === 0)
    throw new Error(`Internal error: invalid scc group for ${sccId}`, { cause: { ctx, sccId, group } });

  let ev: RV<K>[] = [];
  for (let i = 0; i < group.length; i++) {
    const st = group[i];
    const x = evalStateBody(ctx, st, ctx.lexicalStates.has(st));
    ev.push(x);
  }

  return (rc: RuntimeCtx<K>, pos: number) => {
    let entries: MemoEntry[] = Array(group.length);
    for (let i = 0; i < group.length; i++) {
      const st = group[i];
      let memo = rc.getMemo(st, pos);
      if (!memo) {
        memo = { result: { type: 'none', ok: false, pos, value: null } };
        rc.setMemo(st, pos, memo);
      }
      entries[i] = memo;
    }
    let changed = true;
    while (changed) {
      changed = false;

      for (let i = 0; i < group.length; i++) {
        const entry = entries[i];
        const candidate = ev[i](rc, pos);

        if (improves(candidate, entry.result)) {
          entry.result = candidate;
          changed = true;
        } else if (improves_error(candidate, entry.result)) {
          entry.result = candidate;
        }
      }
    }
  }
}

function evalStateBody<K extends StateName>(
  ctx: ParserCtx<K>,
  state: StateKey<K>,
  lexical: boolean
): RV<K> {
  const seq = ctx.graph.get(state);
  if (!seq)
    throw new Error(`Invalid state: ${state}`, { cause: { ctx, state } });

  return buildSequence(ctx, seq, lexical);
}

function buildChoice<K extends StateName>(
  ctx: ParserCtx<K>,
  choice: Choice<K>,
  lexical: boolean
): RV<K> {
  const [opMask, _, body] = choice.operators;
  if (body.length === 1) {
    return withOperators(ctx, choice, (body, lex) => {
      const term = body[0];
      throwOnGeneric(term);
      const x = buildTerm(ctx, term, lex);
      return (rc, pos) => {
        const r = x(rc, pos);
        return { type: 'choice', ok: r.ok, pos: r.pos, value: r, alt: 0 };
      }
    }, lexical);
  }
  const hasOrderedChoice = opMask & OP_MAP['/'];
  if (hasOrderedChoice) {
    return withOperators(ctx, choice, (body, lex) => {
      const ev: RV<K>[] = [];
      for (const term of body) {
        throwOnGeneric(term);
        const x = buildTerm(ctx, term, lex);
        ev.push(x);
      }
      return (rc, pos) => {
        let error: Result = { type: 'none', ok: false, pos, value: null };
        let errorId: number | null = null;
        for (let i = 0; i < ev.length; i++) {
          const alt = ev[i];
          const r = alt(rc, pos);
          if (r.ok)
            return { type: 'choice', ok: r.ok, pos: r.pos, value: r, alt: i };
          if (improves_error(r, error)) {
            error = r;
            errorId = i;
          }
        }
        return { type: 'choice', ok: error.ok, pos: error.pos, value: error, alt: errorId };
      }
    }, lexical);
  }
  return withOperators(ctx, choice, (body, lex) => {
    const ev: RV<K>[] = [];
    for (const term of body) {
      throwOnGeneric(term);
      const x = buildTerm(ctx, term, lex);
      ev.push(x);
    }
    return (rc, pos) => {
      let best: Result = { type: 'none', ok: false, pos, value: null };
      let bestId: number | null = null;
      for (let i = 0; i < body.length; i++) {
        const alt = ev[i];
        const r = alt(rc, pos);
        if (improves(r, best)) {
          best = r;
          bestId = i;
        } else if (improves_error(r, best)) {
          best = r;
          bestId = i;
        }
      }
      return { type: 'choice', ok: best.ok, pos: best.pos, value: best, alt: bestId };
    }
  }, lexical);
}

function skipWs(rc: RuntimeCtx<StateName>, pos: number): [MatcherValue | null, number] {
  rc.ws.lastIndex = pos;
  const match = rc.ws.exec(rc.input);
  if (match) {
    let ws = match[0];
    pos += ws.length;
    return [ws, pos];
  }
  return [null, pos];
};

function buildTerm<K extends StateName>(
  ctx: ParserCtx<K>,
  term: RegExp | StateKey<K> | Choice<K> | Sequence<K>,
  lexical: boolean
): RV<K> {
  if (term instanceof RegExp) {
    const x = buildRegex(ctx, term);
    if (lexical)
      return (rc, pos) => {
        const result = x(rc, pos);
        return result;
      }
    return (rc, pos) => {
      let ws;
      [ws, pos] = skipWs(rc, pos);
      const result = x(rc, pos);
      if (ws) result.ws = result.ws ? ws + result.ws : ws;
      return result;
    }
  } else if (term instanceof Sequence) {
    return buildSequence(ctx, term, lexical);
  } else if (term instanceof Choice) {
    return buildChoice(ctx, term, lexical);
  } else {
    if (lexical)
      return (rc, pos) => {
        const result = rc.call(term, pos);
        return result;
      }
    return (rc, pos) => {
      let ws;
      [ws, pos] = skipWs(rc, pos);
      const result = rc.call(term, pos);
      if (ws) result.ws = result.ws ? ws + result.ws : ws;
      return result;
    }
  }
}

function buildSequence<K extends StateName>(
  ctx: ParserCtx<K>,
  seq: Sequence<K>,
  lexical: boolean
): RV<K> {
  const [_opMask, _, body] = seq.operators;
  if (body.length === 1) {
    return withOperators(ctx, seq, (body, lex) => {
      const term = body[0];
      throwOnGeneric(term);
      const x = buildTerm(ctx, term, lex);
      return (rc, pos) => {
        const r = x(rc, pos);
        return { type: 'sequence', ok: r.ok, pos: r.pos, value: [r] };
      }
    }, lexical);
  }
  return withOperators(ctx, seq, (body, lex) => {
    const ev: RV<K>[] = [];
    for (const term of body) {
      throwOnGeneric(term);
      const x = buildTerm(ctx, term, lex);
      ev.push(x);
    }
    return (rc, pos) => {
      let curPos = pos;
      let results: Result[] = [];
      for (const x of ev) {
        const r: Result = x(rc, curPos);
        results.push(r); curPos = r.pos;
        if (!r.ok)
          return { type: 'sequence', ok: false, pos: curPos, value: results };
      }
      return { type: 'sequence', ok: true, pos: curPos, value: results };
    }
  }, lexical);
}

function buildRegex<K extends StateName>(ctx: ParserCtx<K>, re: RegExp): RV<K> {
  if (!re.sticky || re.global)
    throw new Error(`matchRegex: Expected sticky and non-global regex, got: ${re.flags}`, { cause: re });

  return (rc, pos) => {
    re.lastIndex = pos;
    const m = re.exec(rc.input);

    if (!m) return { type: 'terminal', ok: false, pos, value: null };
    const value = m[0];
    return { type: 'terminal', ok: true, pos: pos + value.length, value };
  }
}

export type Operators<K extends StateName> = readonly [
  opMask: number,
  attrs: readonly string[],
  body: readonly (Exclude<GraphToken<K>, StandaloneOperator> | Generic)[]
];

function throwOnGeneric<K extends StateName>(x: Exclude<GraphToken<K>, StandaloneOperator> | Generic):
  asserts x is Exclude<GraphToken<K>, StandaloneOperator> {
  if (isGeneric(x))
    throw new Error(
      'Generic states must be referenced using a CallToken, not as plain state references.',
      { cause: x }
    );
}

function withOperators<K extends StateName>(
  ctx: ParserCtx<K>,
  data: GraphCollection<K>,
  makeRun: (body: Operators<K>[2], lexical: boolean) => RV<K>,
  lexical: boolean,
): RV<K> {
  const [opMask, attrs, body] = data.operators;

  const hasPosLA = opMask & OP_MAP['&'];
  const hasNegLA = opMask & OP_MAP['!'];
  const hasStar = opMask & OP_MAP['*'];
  const hasPlus = opMask & OP_MAP['+'];
  const hasOpt = opMask & OP_MAP['?'];
  const hasAt = opMask & OP_MAP['@'];
  const hasRewind = opMask & OP_MAP['$'];
  const hasLex = opMask & OP_MAP['#'];
  const hasSyn = opMask & OP_MAP['%'];
  if (hasLex) lexical = true;
  else if (hasSyn) lexical = false;

  let r = makeRun(body, lexical);

  if (hasAt) {
    const x = r;
    r = lexical ? (rc, pos) => {
      const r = x(rc, pos);
      return {
        type: 'iteration',
        ok: r.ok,
        pos: hasRewind ? (r.ok ? r.pos : pos) : r.pos,
        value: [r],
        kind: '@'
      };
    } : (rc, pos) => {
      let [ws, runPos] = skipWs(rc, pos);
      const r = x(rc, runPos);
      return {
        type: 'iteration',
        ok: r.ok,
        pos: hasRewind ? (r.ok ? r.pos : pos) : r.pos,
        value: [r],
        kind: '@',
        ws
      };
    };
  } else if (hasOpt) {
    const x = r;
    r = lexical ? (rc, pos) => {
      const r = x(rc, pos);
      if (!r.ok && (hasRewind || r.pos === pos))
        return {
          type: 'iteration',
          ok: true,
          pos, value: [],
          kind: '?'
        };
      else
        return {
          type: 'iteration',
          ok: r.ok,
          pos: r.pos,
          value: [r],
          kind: '?'
        };
    } : (rc, pos) => {
      let [ws, runPos] = skipWs(rc, pos);
      const r = x(rc, runPos);
      if (!r.ok && (hasRewind || r.pos === runPos))
        return {
          type: 'iteration',
          ok: true,
          pos, value: [],
          kind: '?'
        };
      else
        return {
          type: 'iteration',
          ok: r.ok,
          pos: r.pos,
          value: [r],
          kind: '?',
          ws
        };
    };
  } else if (hasStar) {
    const x = r;
    r = lexical ? (rc, pos) => {
      const results: Result[] = [];
      let curPos = pos;

      while (true) {
        const r = x(rc, curPos);
        if (r.pos === curPos) break;
        if (hasRewind && !r.ok) break;

        results.push(r);
        curPos = r.pos;
        if (!r.ok) break;
      }

      return {
        type: 'iteration',
        ok: results.length ? results[results.length - 1].ok : true,
        pos: curPos,
        value: results,
        kind: hasPlus ? '+' : '*'
      };
    } : (rc, pos) => {
      const results: Result[] = [];
      let curPos = pos;

      while (true) {
        let [ws, runPos] = skipWs(rc, curPos);
        const r = x(rc, runPos);
        if (ws) r.ws = r.ws ? ws + r.ws : ws;

        if (r.pos === runPos) break;
        if (hasRewind && !r.ok) break;
        results.push(r);
        curPos = r.pos;
        if (!r.ok) break;
      }

      return {
        type: 'iteration',
        ok: results.length ? results[results.length - 1].ok : true,
        pos: curPos,
        value: results,
        kind: hasPlus ? '+' : '*'
      };
    };
  } else if (hasPlus) {
    const x = r;
    r = lexical ? (rc, pos) => {
      const results: Result[] = [];
      let curPos = pos;

      while (true) {
        const r = x(rc, curPos);
        if (results.length) {
          if (r.pos === curPos) break;
          if (hasRewind && !r.ok) break;
        }
        results.push(r);
        curPos = r.pos;
        if (!r.ok) break;
      }

      return {
        type: 'iteration',
        ok: results.length ? results[results.length - 1].ok : true,
        pos: curPos,
        value: results,
        kind: hasPlus ? '+' : '*'
      };
    } : (rc, pos) => {
      const results: Result[] = [];
      let curPos = pos;

      while (true) {
        let [ws, runPos] = skipWs(rc, curPos);
        const r = x(rc, runPos);
        if (ws) r.ws = r.ws ? ws + r.ws : ws;

        if (results.length) {
          if (r.pos === runPos) break;
          if (hasRewind && !r.ok) break;
        }
        results.push(r);
        curPos = r.pos;
        if (!r.ok) break;
      }

      return {
        type: 'iteration',
        ok: results.length ? results[results.length - 1].ok : true,
        pos: curPos,
        value: results,
        kind: hasPlus ? '+' : '*'
      };
    };
  }

  // --- rewind ---
  if (hasRewind && !hasAt && !hasOpt && !hasStar && !hasPlus) {
    const x = r;
    r = (rc, pos) => {
      const result = x(rc, pos);
      return {
        type: 'rewind',
        ok: result.ok,
        pos: result.ok ? result.pos : pos,
        value: result
      }
    };
  }

  // --- lookahead ---
  if (hasPosLA) {
    const x = r;
    r = (rc, pos) => {
      const result = x(rc, pos);
      return {
        type: 'lookahead',
        ok: result.ok,
        pos,
        value: result,
        positive: true
      }
    };
  } else if (hasNegLA) {
    const x = r;
    r = (rc, pos) => {
      const result = x(rc, pos);
      return {
        type: 'lookahead',
        ok: !result.ok,
        pos,
        value: result,
        positive: false
      }
    };
  }

  if (attrs.length > 0) {
    const x = r;
    r = (rc, pos) => {
      const result = x(rc, pos);
      return {
        type: 'attrs',
        ok: result.ok,
        pos: result.pos,
        value: result,
        attrs: attrs.slice()
      }
    };
  }

  return r;
}

const WS_REGEX = /\s+/y;
const LEXICAL_REGEX = /^[a-z_]/;
export function build<K extends StateName>(
  graph: Graph<K>
): (input: string, start: StateKey<K>, ws?: RegExp) => Result & { type: 'root'; } {
  const lexicalStates = new Set<StateKey<K>>();
  const allStates = new Set(graph.keys());
  for (const stateLabel of allStates) {
    if (LEXICAL_REGEX.test(stateLabel))
      lexicalStates.add(stateLabel);
  }

  const ctx: ParserCtx<K> = {
    graph,
    sccOf: graph.sccOf,
    sccMembers: graph.sccMembers,
    lexicalStates
  };

  const states = new Map<StateKey<K>, StateRV<K>>();
  for (const [stateLabel, state] of graph.entries()) {
    if (state.generic) continue;
    states.set(stateLabel, buildState(ctx, stateLabel));
  }

  return function parse(input, start, ws) {
    ws ??= WS_REGEX;
    if (!ws.sticky || ws.global) {
      throw new Error("Whitespace regex must be sticky and non-global");
    }

    const x = states.get(start);
    if (!x)
      throw new Error(`Cannot start at generic state: ${start}`, { cause: { start } });

    const memos = new Map<StateKey<K>, (MemoEntry | null)[]>();
    for (const stateLabel of allStates) {
      memos.set(stateLabel, Array(input.length).fill(null));
    }

    const rc: RuntimeCtx<K> = {
      input,

      getMemo(state, pos) {
        return memos.get(state)![pos];
      },
      setMemo(state, pos, entry) {
        memos.get(state)![pos] = entry;
      },
      call(state, pos) {
        return states.get(state)!(rc, pos);
      },

      ws
    };

    const result = x(rc, 0);
    const lexical = lexicalStates.has(start);
    let trailing_ws = null, endPos = result.pos;
    if (!lexical) {
      [trailing_ws, endPos] = skipWs(rc, result.pos);
    }

    if (result.ok && endPos === input.length) {
      return {
        type: 'root',
        ok: true, pos: endPos, value: result,
        trailing_ws
      };
    }

    return {
      type: 'root',
      ok: false, pos: endPos, value: result,
      trailing_ws
    };
  }
} 
