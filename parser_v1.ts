import { Graph, isGeneric, type GraphToken, Choice, Sequence, type GraphCollection, type StandaloneOperator, type StateKey, type StateName, type IterationOperator, type Generic, OP_MAP } from './graph.js';
import type { SccId } from './scc.js';
import type { MapView } from './shared.js';

export type ResultValue =
  | Result
  | Result[]
  | MatcherValue
  | null;

export type BaseResult = {
  ok: boolean;
  pos: number;
  value: ResultValue;
  ws?: MatcherValue | null;
};
export type Result =
  | BaseResult & { type: 'none'; ok: false; value: null; }
  | BaseResult & { type: 'lookahead'; positive: boolean; value: Result; }
  | BaseResult & { type: 'state'; state: StateName; value: Result; }
  | BaseResult & { type: 'choice'; value: Result; alt: number | null; }
  | BaseResult & { type: 'sequence'; value: Result[]; }
  | BaseResult & { type: 'terminal'; value: MatcherValue; ok: true; }
  | BaseResult & { type: 'terminal'; value: null; ok: false; }
  | BaseResult & { type: 'iteration'; kind: IterationOperator; value: Result[]; }
  | BaseResult & { type: 'attrs'; attrs: string[]; value: Result; }
  | BaseResult & { type: 'rewind'; value: Result; }
  | BaseResult & { type: 'root'; trailing_ws: MatcherValue | null; value: Result & { type: 'state'; }; };

export type MatcherValue = string;

type MemoEntry = { result: Result; };
type ParserCtx<K extends StateName> = Readonly<{
  graph: Graph<K>;
  input: string;

  getMemo(state: StateKey<K>, pos: number): MemoEntry | null;
  setMemo(state: StateKey<K>, pos: number, entry: MemoEntry): void;

  sccOf: MapView<StateKey<K>, SccId>;
  sccMembers: MapView<SccId, StateKey<K>[]>;

  ws: RegExp;
  lexicalStates: Set<StateKey<K>>;
}>;

function improves(next: Result, prev: Result): boolean {
  return next.ok && (!prev.ok || next.pos > prev.pos);
}

function improves_error(next: Result, prev: Result): boolean {
  return !prev.ok && !next.ok && (next.pos >= prev.pos);
}

function parseState<K extends StateName>(
  ctx: ParserCtx<K>,
  state: StateKey<K>,
  pos: number
): Result & { type: 'state'; } {
  const existing = ctx.getMemo(state, pos);
  if (existing) {
    const result = existing.result;
    return { type: 'state', ok: result.ok, pos: result.pos, value: result, state };
  }

  const sid = ctx.sccOf.get(state);
  if (sid === undefined) {
    const result = evalStateBody(ctx, state, pos, ctx.lexicalStates.has(state));
    ctx.setMemo(state, pos, { result });
    return { type: 'state', ok: result.ok, pos: result.pos, value: result, state };
  }

  solveSCC(ctx, sid, pos);
  const entry = ctx.getMemo(state, pos);
  if (!entry)
    throw new Error(`Internal error: No result generated by solveSCC`, { cause: { ctx, state, entry: entry, pos } });

  const result = entry.result;
  return { type: 'state', ok: result.ok, pos: result.pos, value: result, state };
}

function solveSCC<K extends StateName>(
  ctx: ParserCtx<K>,
  sccId: SccId,
  pos: number
): void {
  const group = ctx.sccMembers.get(sccId);
  if (!group || group.length === 0)
    throw new Error(`Internal error: invalid scc group for ${sccId}`, { cause: { ctx, sccId, group, pos } });

  let entries: MemoEntry[] = [];
  let lex: boolean[] = [];
  for (let i = 0; i < group.length; i++) {
    const st = group[i];
    let memo = ctx.getMemo(st, pos);
    if (!memo) {
      memo = { result: { type: 'none', ok: false, pos, value: null } };
      ctx.setMemo(st, pos, memo);
    }
    entries.push(memo);
    lex.push(ctx.lexicalStates.has(st));
  }

  let changed = true;
  while (changed) {
    changed = false;

    for (let i = 0; i < group.length; i++) {
      const st = group[i];
      const entry = entries[i];
      const candidate = evalStateBody(ctx, st, pos, lex[i]);

      if (improves(candidate, entry.result)) {
        entry.result = candidate;
        changed = true;
      } else if (improves_error(candidate, entry.result)) {
        entry.result = candidate;
      }
    }
  }
}

function evalStateBody<K extends StateName>(
  ctx: ParserCtx<K>,
  state: StateKey<K>,
  pos: number,
  lexical: boolean
): Result {
  const seq = ctx.graph.get(state);
  if (!seq)
    throw new Error(`Invalid state: ${state}`, { cause: { ctx, state } });

  return evalSequence(ctx, seq, pos, lexical);
}

function evalChoice<K extends StateName>(
  ctx: ParserCtx<K>,
  choice: Choice<K>,
  pos: number,
  lexical: boolean
): Result {
  const opMask = choice.operators[0];
  const hasOrderedChoice = opMask & OP_MAP['/'];
  if (hasOrderedChoice) {
    return withOperators(ctx, choice, pos, function (pos, body, lex) {
      let error: Result = { type: 'none', ok: false, pos, value: null };
      let errorId: number | null = null;
      for (let i = 0; i < body.length; i++) {
        const alt = body[i];
        throwOnGeneric(alt);
        const r = evalTerm(ctx, alt, pos, lex);
        if (r.ok)
          return { type: 'choice', ok: r.ok, pos: r.pos, value: r, alt: i };
        if (improves_error(r, error)) {
          error = r;
          errorId = i;
        }
      }
      return { type: 'choice', ok: error.ok, pos: error.pos, value: error, alt: errorId };
    }, lexical);
  }
  return withOperators(ctx, choice, pos, function (pos, body, lex) {
    let best: Result = { type: 'none', ok: false, pos, value: null };
    let bestId: number | null = null;
    for (let i = 0; i < body.length; i++) {
      const alt = body[i];
      throwOnGeneric(alt);
      const r = evalTerm(ctx, alt, pos, lex);
      if (improves(r, best)) {
        best = r;
        bestId = i;
      } else if (improves_error(r, best)) {
        best = r;
        bestId = i;
      }
    }
    return { type: 'choice', ok: best.ok, pos: best.pos, value: best, alt: bestId };
  }, lexical);
}

function skipWs<K extends StateName>(ctx: ParserCtx<K>, lexical: boolean, pos: number): [MatcherValue | null, number] {
  if (lexical) return [null, pos];

  ctx.ws.lastIndex = pos;
  const match = ctx.ws.exec(ctx.input);
  if (match) {
    let ws = match[0];
    pos += ws.length;
    return [ws, pos];
  }
  return [null, pos];
}

function evalTerm<K extends StateName>(
  ctx: ParserCtx<K>,
  term: RegExp | StateKey<K> | Choice<K> | Sequence<K>,
  pos: number,
  lexical: boolean
): Result {
  let result: Result, ws: MatcherValue | null = null;

  if (term instanceof RegExp) {
    [ws, pos] = skipWs(ctx, lexical, pos);
    result = matchRegex(ctx.input, term, pos);
  } else if (term instanceof Sequence) {
    result = evalSequence(ctx, term, pos, lexical);
  } else if (term instanceof Choice) {
    result = evalChoice(ctx, term, pos, lexical);
  } else {
    [ws, pos] = skipWs(ctx, lexical, pos);
    result = parseState(ctx, term, pos);
  }

  if (ws) result.ws = result.ws ? ws + result.ws : ws;
  return result;
}

function evalSequence<K extends StateName>(
  ctx: ParserCtx<K>,
  seq: Sequence<K>,
  pos: number,
  lexical: boolean
): Result {
  return withOperators(ctx, seq, pos, function (pos, body, lex) {
    let curPos = pos;
    let results: Result[] = [];
    for (const term of body) {
      throwOnGeneric(term);
      const r: Result = evalTerm(ctx, term, curPos, lex);
      results.push(r); curPos = r.pos;
      if (!r.ok)
        return { type: 'sequence', ok: false, pos: curPos, value: results };
    }
    return { type: 'sequence', ok: true, pos: curPos, value: results };
  }, lexical);
}

function matchRegex(input: string, re: RegExp, pos: number): Result {
  if (!re.sticky || re.global)
    throw new Error(`matchRegex: Expected sticky and non-global regex, got: ${re.flags}`, { cause: re });

  re.lastIndex = pos;
  const m = re.exec(input);

  if (!m) return { type: 'terminal', ok: false, pos, value: null };
  const value = m[0];
  return { type: 'terminal', ok: true, pos: pos + value.length, value };
}

export type Operators<K extends StateName> = readonly [
  opMask: number,
  attrs: readonly string[],
  body: readonly (Exclude<GraphToken<K>, StandaloneOperator> | Generic)[]
];

function throwOnGeneric<K extends StateName>(x: Exclude<GraphToken<K>, StandaloneOperator> | Generic):
  asserts x is Exclude<GraphToken<K>, StandaloneOperator> {
  if (isGeneric(x))
    throw new Error(
      'Generic states must be referenced using a CallToken, not as plain state references.',
      { cause: x }
    );
}

function withOperators<K extends StateName>(
  ctx: ParserCtx<K>,
  seq: GraphCollection<K>,
  pos: number,
  run: (pos: number, body: Operators<K>[2], lexical: boolean) => Result,
  lexical: boolean,
  operators = seq.operators,
): Result {
  const [opMask, attrs, body] = operators;

  const hasPosLA = opMask & OP_MAP['&'];
  const hasNegLA = opMask & OP_MAP['!'];
  const hasStar = opMask & OP_MAP['*'];
  const hasPlus = opMask & OP_MAP['+'];
  const hasOpt = opMask & OP_MAP['?'];
  const hasAt = opMask & OP_MAP['@'];
  const hasRewind = opMask & OP_MAP['$'];
  const hasLex = opMask & OP_MAP['#'];
  const hasSyn = opMask & OP_MAP['%'];
  if (hasLex) lexical = true;
  else if (hasSyn) lexical = false;

  let result: Result | undefined;
  if (hasAt) {
    let [ws, runPos] = skipWs(ctx, lexical, pos);
    const r = run(runPos, body, lexical);
    result = {
      type: 'iteration',
      ok: r.ok,
      pos: hasRewind ? (r.ok ? r.pos : pos) : r.pos,
      value: [r],
      kind: '@',
      ws
    };
  } else if (hasOpt) {
    let [ws, runPos] = skipWs(ctx, lexical, pos);
    const r = run(runPos, body, lexical);
    if (!r.ok && (r.pos === runPos || hasRewind))
      result = {
        type: 'iteration',
        ok: true,
        pos, value: [],
        kind: '?'
      };
    else
      result = {
        type: 'iteration',
        ok: r.ok,
        pos: r.pos,
        value: [r],
        kind: '?',
        ws
      };
  } else if (hasStar || hasPlus) {
    const results: Result[] = [];
    let curPos = pos;

    while (true) {
      let [ws, runPos] = skipWs(ctx, lexical, curPos);
      const r = run(runPos, body, lexical);
      if (ws) r.ws = r.ws ? ws + r.ws : ws;

      if (r.pos === runPos) break;
      if (hasRewind && !r.ok) break;
      results.push(r);
      curPos = r.pos;
      if (!r.ok) break;
    }

    if (hasPlus && results.length === 0) {
      let ws;
      [ws, curPos] = skipWs(ctx, lexical, curPos);
      const r = run(curPos, body, lexical);
      if (ws) r.ws = r.ws ? ws + r.ws : ws;
      results.push(r);
      curPos = r.pos;
    }

    result = {
      type: 'iteration',
      ok: results.length ? results[results.length - 1].ok : true,
      pos: curPos,
      value: results,
      kind: hasPlus ? '+' : '*'
    };
  }

  // --- normal evaluation ---
  if (!result) result = run(pos, body, lexical);

  // --- rewind ---
  if (hasRewind && !hasAt && !hasOpt && !hasStar && !hasPlus) {
    result = {
      type: 'rewind',
      ok: result.ok,
      pos: result.ok ? result.pos : pos,
      value: result
    };
  }

  // --- lookahead ---
  if (hasPosLA) {
    result = {
      type: 'lookahead',
      ok: result.ok,
      pos,
      value: result,
      positive: true
    };
  } else if (hasNegLA) {
    result = {
      type: 'lookahead',
      ok: !result.ok,
      pos,
      value: result,
      positive: false
    };
  }

  if (attrs.length > 0) {
    result = {
      type: 'attrs',
      ok: result.ok,
      pos: result.pos,
      value: result,
      attrs: attrs.slice()
    };
  }

  return result;
}

const WS_REGEX = /\s+/y;
const LEXICAL_REGEX = /^[a-z_]/;
export function parse<K extends StateName>(
  graph: Graph<K>,
  input: string,
  start: StateKey<K>,
  ws?: RegExp
): Result & { type: 'root'; } {
  ws ??= WS_REGEX;
  if (!ws.sticky || ws.global) {
    throw new Error("Whitespace regex must be sticky and non-global");
  }

  const memos = new Map<StateKey<K>, (MemoEntry | null)[]>();
  const lexicalStates = new Set<StateKey<K>>();
  for (const stateLabel of graph.keys()) {
    memos.set(stateLabel, Array(input.length).fill(null));
    if (LEXICAL_REGEX.test(stateLabel))
      lexicalStates.add(stateLabel);
  }

  const ctx: ParserCtx<K> = {
    graph,
    input,

    getMemo(state, pos) {
      return memos.get(state)![pos];
    },
    setMemo(state, pos, entry) {
      memos.get(state)![pos] = entry;
    },

    sccOf: graph.sccOf,
    sccMembers: graph.sccMembers,
    ws, lexicalStates
  };

  if (graph.get(start)?.generic)
    throw new Error(`Cannot start at generic state: ${start}`, { cause: { graph, start } });

  const result = parseState(ctx, start, 0);
  const [trailing_ws, endPos] = skipWs(ctx, lexicalStates.has(start), result.pos);

  if (result.ok && endPos === input.length) {
    return {
      type: 'root',
      ok: true, pos: endPos, value: result,
      trailing_ws
    };
  }

  return {
    type: 'root',
    ok: false, pos: endPos, value: result,
    trailing_ws
  };
}

/*
Would require knowing how far the regex engine looked ahead or behind...

export function matcher<K extends StateName>(
  graph: Graph<K>,
  ws?: RegExp
) {
  ws ??= WS_REGEX;
  if (!ws.sticky || ws.global) {
    throw new Error("Whitespace regex must be sticky and non-global");
  }

  const memos = new Map<StateKey<K>, (MemoEntry | null)[]>();
  const lexicalStates = new Set<StateKey<K>>();
  for (const stateLabel of graph.keys()) {
    memos.set(stateLabel, []);
    if (LEXICAL_REGEX.test(stateLabel))
      lexicalStates.add(stateLabel);
  }

  const ctx: ParserCtx<K> = {
    graph,
    input: '',

    getMemo(state, pos) {
      return memos.get(state)![pos];
    },
    setMemo(state, pos, entry) {
      memos.get(state)![pos] = entry;
    },

    sccOf: graph.sccOf,
    sccMembers: graph.sccMembers,
    ws, lexicalStates
  };

  return function parse(
    input: string,
    leftPos: number, rightPos: number,
    start: StateKey<K>
  ): Result & { type: 'root'; } {
    for (const stateLabel of graph.keys()) {
      let arr = memos.get(stateLabel)!;
      arr = arr.slice(0, leftPos).concat(
        new Array(input.length).fill(null),
        arr.slice(rightPos));
      memos.set(stateLabel, arr);
      for (let pos = 0; pos < leftPos; pos++) {
        let col = arr[pos];
        if (col != null && col.result.pos > leftPos) {
          arr[pos] = null;
        }
      }
    }

    // @ts-expect-error
    ctx.input = ctx.input.slice(0, leftPos) + input + ctx.input.slice(rightPos);

    if (graph.get(start)?.generic)
      throw new Error(`Cannot start at generic state: ${start}`, { cause: { graph, start } });

    const result = parseState(ctx, start, 0);
    const [trailing_ws, endPos] = skipWs(ctx, lexicalStates.has(start), result.pos);

    if (result.ok && endPos === ctx.input.length) {
      return {
        type: 'root',
        ok: true, pos: endPos, value: result,
        trailing_ws
      };
    }

    return {
      type: 'root',
      ok: false, pos: endPos, value: result,
      trailing_ws
    };
  }
}

*/
